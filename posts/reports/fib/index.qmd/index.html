<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.555">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="mlmv">
<meta name="dcterms.date" content="2025-10-03">

<title>/ - mathematical objects in their spaces 3</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../">
<script src="../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>html{ scroll-behavior: smooth; }</style>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../../index.html">
    <span class="navbar-title">/</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../posts/reports/.*"> 
<span class="menu-text">reports</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../../posts/experiments/.*"> 
<span class="menu-text">experiments</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active" data-toc-expanded="99">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#object-and-space" id="toc-object-and-space" class="nav-link active" data-scroll-target="#object-and-space"><span class="header-section-number">0.1</span> Object and space</a></li>
  <li><a href="#behaviors-of-the-object" id="toc-behaviors-of-the-object" class="nav-link" data-scroll-target="#behaviors-of-the-object"><span class="header-section-number">0.2</span> Behaviors of the object</a></li>
  <li><a href="#observables-and-what-to-expect-on-screen" id="toc-observables-and-what-to-expect-on-screen" class="nav-link" data-scroll-target="#observables-and-what-to-expect-on-screen"><span class="header-section-number">0.3</span> Observables and what to expect on screen</a></li>
  <li><a href="#implementation-note-for-reproducibility" id="toc-implementation-note-for-reproducibility" class="nav-link" data-scroll-target="#implementation-note-for-reproducibility"><span class="header-section-number">0.4</span> Implementation note (for reproducibility)</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references"><span class="header-section-number">0.5</span> References</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">mathematical objects in their spaces 3</h1>
<p class="subtitle lead">behavioural experiment analysis: habituation, sensitization, anticipation, associative conditioning, and delayed gratification</p>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>mlmv </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">October 3, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>In its native space, the continuum fib seems to have the five behaviors (habituation, sensitization, anticipation, associative recall, delayed gratification) and these are expressed by a adaptive steering. The continuous Fibonacci function drives a single 3D golden helix body that moves on a horn‑like habitat; by changing only a small external schedule and one adaptive gain, the same object exhibits habituation, sensitization, anticipation, associative recall, and delayed gratification. The construction rests on continuous Binet calculus for smooth evolution and on published Fibonacci/Lucas helices for the 3D geometry, ensuring mathematical coherence and interpretability for non‑specialists and experts alike.</p>
<section id="object-and-space" class="level3" data-number="0.1">
<h3 data-number="0.1" class="anchored" data-anchor-id="object-and-space"><span class="header-section-number">0.1</span> Object and space</h3>
<p>The object is the time‑continuous Fibonacci function defined from the Binet calculus <span class="math inline">\(F(t)=\frac{\phi^{t}-(-\phi^{-1})^{t}}{\phi+\phi^{-1}}\)</span> with <span class="math inline">\(\phi=(1+\sqrt{5})/2\)</span>, so <span class="math inline">\(F(n)=F_n\)</span> for integers and the same law extends to all real <span class="math inline">\(t\)</span> for smooth motion on a curve. The space for a 3D Fibonacci helix habitat is built from a center line with radius <span class="math inline">\(R(t)\)</span> and pitch <span class="math inline">\(p\)</span> and a thin shrinking tube <em>shofar</em>. Graça has shown that Fibonacci/Lucas helices admit explicit parameterisations with constant pitch, which justifies a true 3D helical space rather than a flat 2D spiral. For coordinates, the centerline is <span class="math inline">\(x(t)=R(t)\cos\theta(t)\)</span>, <span class="math inline">\(y(t)=R(t)\sin\theta(t)\)</span>, <span class="math inline">\(z(t)=p\,t\)</span> with radius <span class="math inline">\(R(t)=R_0\,F(t)/F(1)\)</span> (or <span class="math inline">\(R_0\phi^{t-1}\)</span> as a geometric variant) and a golden turning step <span class="math inline">\(\Delta\theta_\star=2\pi(1-1/\phi)\)</span> that sets the canonical angular advance per unit time.</p>
<p>A steering variable <span class="math inline">\(\theta(t)\)</span> evolves under a controlled angular rate <span class="math inline">\(\dot\theta(t)=\Delta\theta_{\mathrm{base}}(t)+u(t)\)</span>, where <span class="math inline">\(\Delta\theta_{\mathrm{base}}(t)\)</span> is a mode‑dependent schedule and <span class="math inline">\(u(t)\)</span> is a small corrective input computed from the current alignment error <span class="math inline">\(e(t)=\mathrm{wrap}(\theta(t)-t\,\Delta\theta_\star)\)</span>. Feedback <span class="math inline">\(u(t)=-g(t)\,e(t)-d\,\dot e(t)\)</span> with a fixed derivative coefficient <span class="math inline">\(d&gt;0\)</span> for damping and an adaptive gain <span class="math inline">\(g(t)\ge0\)</span> that changes slowly to express habituation, sensitization, and recall within the same law for the same body. Plasticity: $ g(t)=e(t)-g(t)+(t) $, where <span class="math inline">\(\alpha&gt;0\)</span> increases gain when the body is well aligned with the golden turn, <span class="math inline">\(\beta&gt;0\)</span> enforces slow decay (habituation), and <span class="math inline">\(\mathrm{pair}(t)\)</span> is a temporary pairing input used only during associative training intervals; this single scalar adaptation suffices to realize all five behaviors without changing the object’s equations of motion.</p>
</section>
<section id="behaviors-of-the-object" class="level3" data-number="0.2">
<h3 data-number="0.2" class="anchored" data-anchor-id="behaviors-of-the-object"><span class="header-section-number">0.2</span> Behaviors of the object</h3>
<p>Habituation can be seen as <span class="math inline">\(\Delta\theta_{\mathrm{base}}(t)=\Delta\theta_\star+\varepsilon\sin(2\pi t/T)\)</span> with small <span class="math inline">\(\varepsilon\)</span>; the repeated disturbance decays in effective influence as <span class="math inline">\(g(t)\)</span> relaxes and the phase error <span class="math inline">\(e(t)\)</span> converges back toward zero, visible as decreasing corrective effort at the same stimulus strength. Sensitisation <span class="math inline">\(\Delta\theta_{\mathrm{base}}(t)=\Delta\theta_\star+\delta e^{-t/\tau}\)</span> so the base turn drifts toward the golden value. As alignment improves, <span class="math inline">\(\alpha\cos e(t)\)</span> keeps <span class="math inline">\(g(t)\)</span> elevated and the object reacts more strongly, causing faster error reduction near the target and a visibly steeper improvement in alignment and packing along the helix. Anticipation is given by <span class="math inline">\(\Delta\theta_{\mathrm{base}}(t)=\Delta\theta_\star+\eta\sin(\omega t)\)</span> with small <span class="math inline">\(\eta\)</span>; the derivative term <span class="math inline">\(-d\dot e\)</span> and the positive gain bias produce a phase lead so the head stays near the best angular window, which should give near‑constant alignment despite periodic driving. Associative recall is given by train with <span class="math inline">\(\mathrm{pair}(t)=\gamma&gt;0\)</span> while <span class="math inline">\(\Delta\theta_{\mathrm{base}}(t)=\Delta\theta_\star\)</span> for <span class="math inline">\(t\in[0,T_{\mathrm{pair}}]\)</span>, then remove both pairing and the golden base; <span class="math inline">\(g(t)\)</span> remains elevated briefly and decays at rate <span class="math inline">\(\beta\)</span>, so the object maintains improved alignment after the cue is gone, a clean mathematical memory ring‑down within the same law. The delayed gratification cycle <span class="math inline">\(\Delta\theta_{\mathrm{base}}(t)\)</span> between poor and golden windows, or equivalently modulate <span class="math inline">\(\alpha\)</span> so learning occurs only in good windows; the body spends energy <span class="math inline">\(E(t)=\langle u^2\rangle\)</span> primarily when progress is possible and idles otherwise, which is visible as growth of spatial uniformity during good windows and conservation during poor windows.</p>
</section>
<section id="observables-and-what-to-expect-on-screen" class="level3" data-number="0.3">
<h3 data-number="0.3" class="anchored" data-anchor-id="observables-and-what-to-expect-on-screen"><span class="header-section-number">0.3</span> Observables and what to expect on screen</h3>
<p>Alignment <span class="math inline">\(A(t)=\cos e(t)\in[-1,1]\)</span> is printed live; values near <span class="math inline">\(1\)</span> indicate the head is steering on the golden turn, with small oscillations in anticipation and a monotone recovery in habituation. Sider for gain <span class="math inline">\(g(t)\)</span> rises in sensitisation and during paired training, decays in habituation, and persists transiently in recall, making the internal “attention” state of the same body legible without any mode‑specific equations. For the uniformity slider, a coefficient‑of‑variation of nearest‑neighbor distances along the body’s recent path provides a geometric packing score <span class="math inline">\(U(t)\)</span>, which improves sharply when <span class="math inline">\(\Delta\theta\)</span> is golden and slowly otherwise, highlighting delayed‑gratification patterns when windows alternate. For ernergy, the running mean of <span class="math inline">\(u(t)^2\)</span> shows effort allocation; it damps in habituation, concentrates near target alignment in sensitization, and redistributes between poor/good windows in delayed scenarios, all with the same object and the same controls.</p>
</section>
<section id="implementation-note-for-reproducibility" class="level3" data-number="0.4">
<h3 data-number="0.4" class="anchored" data-anchor-id="implementation-note-for-reproducibility"><span class="header-section-number">0.4</span> Implementation note (for reproducibility)</h3>
<p>The simulation renders a thin mesh tube (“shofar hull”) around the centerline <span class="math inline">\(x(t)=R(t)\cos\theta(t)\)</span>, <span class="math inline">\(y(t)=R(t)\sin\theta(t)\)</span>, <span class="math inline">\(z(t)=p\,t\)</span> with <span class="math inline">\(R(t)=R_0F(t)/F(1)\)</span>, and advances the single steering state <span class="math inline">\(\theta\)</span> by <span class="math inline">\(\dot\theta=\Delta\theta_{\mathrm{base}}(t)-g(t)e(t)-d\dot e(t)\)</span> while adapting <span class="math inline">\(g\)</span> via <span class="math inline">\(\dot g=\alpha\cos e-\beta g+\mathrm{pair}(t)\)</span>, so all five behaviors arise from the same state variables under different externally scheduled <span class="math inline">\(\Delta\theta_{\mathrm{base}}(t)\)</span> and <span class="math inline">\(\mathrm{pair}(t)\)</span> functions.</p>
</section>
<section id="references" class="level3" data-number="0.5">
<h3 data-number="0.5" class="anchored" data-anchor-id="references"><span class="header-section-number">0.5</span> References</h3>
<ul>
<li>Pashaev, O.K., Nalci, S. “Golden quantum oscillator and Binet–Fibonacci calculus” (continuous Fibonacci/Binet; golden bases), which supports using <span class="math inline">\(F(t)\)</span> for smooth evolution with <span class="math inline">\(F(n)=F_n\)</span> at integer times.</li>
<li>Graça, M.M. “Construction of helices from Lucas and Fibonacci sequences” (parametric 3D Fibonacci/Lucas helices; constant pitch), which supports using a true 3D helical habitat and a horn‑like tube around the centerline for a coherent space.</li>
<li>Golden ratio background and ratio convergence <span class="math inline">\(F_{n+1}/F_n \to \phi\)</span>, which establishes the constants used in the helix and turn schedule.</li>
<li>Minkowski embeddings for number fields (context for separating 2D field geometry from the 3D helix habitat so spaces are not mixed in one scene), which motivates using helix space for dynamics and Minkowski space for planar expositions elsewhere.</li>
</ul>
<p>(https://arxiv.org/abs/1707.09581) (https://arxiv.org/pdf/1107.4389.pdf) (https://www.themathdoctors.org/the-golden-ratio-and-fibonacci/) (http://math.uchicago.edu/~may/REU2012/REUPapers/Comeaux.pdf)</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/mvtta\.github\.io\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p><a href="mailto:mvtta@proton.me">contact</a></p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p>Valdetaro M, 2025</p>
</div>
  </div>
</footer>




<script src="../../../../site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>