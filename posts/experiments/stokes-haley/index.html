<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.555">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>/ - mathematical objects in their spaces 4</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>html{ scroll-behavior: smooth; }</style>


<link rel="stylesheet" href="../../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">/</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../posts/reports/.*"> 
<span class="menu-text">reports</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../posts/experiments/.*"> 
<span class="menu-text">experiments</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active" data-toc-expanded="99">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#overview" id="toc-overview" class="nav-link active" data-scroll-target="#overview"><span class="header-section-number">0.1</span> Overview</a>
  <ul>
  <li><a href="#what-to-look-for-on-screen" id="toc-what-to-look-for-on-screen" class="nav-link" data-scroll-target="#what-to-look-for-on-screen"><span class="header-section-number">0.1.1</span> What to look for on screen</a></li>
  <li><a href="#why-this-is-the-object-in-her-world" id="toc-why-this-is-the-object-in-her-world" class="nav-link" data-scroll-target="#why-this-is-the-object-in-her-world"><span class="header-section-number">0.1.2</span> Why this is the object in her world</a></li>
  <li><a href="#notes-and-extensions" id="toc-notes-and-extensions" class="nav-link" data-scroll-target="#notes-and-extensions"><span class="header-section-number">0.1.3</span> Notes and extensions</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references"><span class="header-section-number">0.1.4</span> References</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">mathematical objects in their spaces 4</h1>
<p class="subtitle lead">surface Navier–Stokes on a torus with harmonic flows</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="overview" class="level3" data-number="0.1">
<h3 data-number="0.1" class="anchored" data-anchor-id="overview"><span class="header-section-number">0.1</span> Overview</h3>
<p>This page simulates incompressible Navier–Stokes directly on a curved surface (a torus), using intrinsic operators and rendering a 3D Hally-style visualization; the same scheme supports harmonic vector fields, which encode topological “memory” on the two fundamental cycles of the torus. The discretization uses the surface vorticity–streamfunction formulation with the Laplace–Beltrami operator, and semi-Lagrangian advection for robust interactive steps in the browser.</p>
<style>
  #surfns-wrap {font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;}
  .controls {display:flex; flex-wrap:wrap; gap:12px; align-items:center; margin:8px 0 12px;}
  .controls label {font-size:0.9rem;}
  .controls input[type=range]{width:160px;}
  .controls button {color:#fff;}
  .panel {background:#0b0f12; border:1px solid #233; border-radius:8px; padding:10px; margin:8px 0;}
  .stat {color:#e0f7fa; font-size:0.9rem; opacity:0.9;}
</style>

<div id="surfns-wrap" class="panel">
  <div class="controls">
    <button id="play">▶ play</button>
    <button id="step">step</button>
    <button id="reset">reset</button>
  <label>ν <input id="nu" type="range" min="0.0002" max="0.004" step="0.0002" value="0.0008"></label>
    <label>dt <input id="dt" type="range" min="0.005" max="0.04" step="0.005" value="0.02"></label>
    <label>harmonic u <input id="hu" type="range" min="-1.2" max="1.2" step="0.05" value="0.0"></label>
    <label>harmonic v <input id="hv" type="range" min="-1.2" max="1.2" step="0.05" value="0.0"></label>
    <label>seed <select id="seed">
      <option value="taylor">Taylor–Green</option>
      <option value="blob">Blob</option>
      <option value="noise">Noise</option>
    </select></label>
  </div>
  <div class="stat" id="status">surface NS: torus | intrinsic operators | harmonic sliders control Hodge components</div>
  <div id="torus3d"></div>
</div>

<script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
<script>
(function(){
  // --------- Manifold: torus parametrization and metric (intrinsic world) ---------
  const R0 = 1.20, r0 = 0.55;           // major/minor radii
  const Nu = 96, Nv = 64;               // grid in (u,v) with periodic BC
  const du = 2*Math.PI/Nu, dv = 2*Math.PI/Nv;
  const uGrid = new Float64Array(Nu), vGrid = new Float64Array(Nv);
  for(let i=0;i<Nu;i++) uGrid[i]=i*du;
  for(let j=0;j<Nv;j++) vGrid[j]=j*dv;

  // metric tensors for torus (u,v) -> R^3
  // g_uu = (R0 + r0 cos v)^2, g_vv = r0^2, g_uv=0, sqrt(g)= r0 (R0 + r0 cos v)
  const g_uu = new Float64Array(Nv), g_vv=new Float64Array(Nv), sqrtg=new Float64Array(Nv), inv_uu=new Float64Array(Nv), inv_vv=new Float64Array(Nv);
  function precomputeMetric(){
    for(let j=0;j<Nv;j++){
      const v=vGrid[j], c=Math.cos(v);
      g_uu[j] = (R0 + r0*c)*(R0 + r0*c);
      g_vv[j] = r0*r0;
      sqrtg[j]= r0*(R0 + r0*c);
      inv_uu[j]= 1/g_uu[j];
      inv_vv[j]= 1/g_vv[j];
    }
  }
  precomputeMetric();
  const idx = (i,j)=> ((j+Nv)%Nv)*Nu + ((i+Nu)%Nu);

  // --------- State: vorticity ω, streamfunction ψ ---------
  let omega = new Float64Array(Nu*Nv).fill(0);
  let omegaTmp = new Float64Array(Nu*Nv).fill(0);
  let psi   = new Float64Array(Nu*Nv).fill(0);
  let psiNew= new Float64Array(Nu*Nv).fill(0);

  // harmonic components (1-form α = a du + b dv -> vector v^u = g^{uu} a, v^v = g^{vv} b)
  let H_u = 0.0, H_v = 0.0;

  // --------- Intrinsic operators ----------
  // Laplace-Beltrami on scalars: Δ_s φ = 1/√g ∂u(√g g^{uu} ∂u φ) + 1/√g ∂v(√g g^{vv} ∂v φ)
  function laplaceScalar(src, dst){
    for(let j=0;j<Nv;j++){
      const jp=(j+1)%Nv, jm=(j-1+Nv)%Nv;
      const su = sqrtg[j];
      const Auu = su*inv_uu[j];
      const Avv_p = sqrtg[jp]*inv_vv[jp];
      const Avv_m = sqrtg[jm]*inv_vv[jm];
      for(let i=0;i<Nu;i++){
        const ip=(i+1)%Nu, im=(i-1+Nu)%Nu;
        const c = idx(i,j);
        const cu= idx(ip,j), cm= idx(im,j);
        const cv= idx(i,jp), cvm=idx(i,jm);
        const duTerm = (Auu*(src[cu]-src[c])/du - Auu*(src[c]-src[cm])/du)/du;
        const dvTerm = (Avv_p*(src[cv]-src[c])/dv - Avv_m*(src[c]-src[cvm])/dv)/dv;
        dst[c] = (duTerm + dvTerm)/su;
      }
    }
  }

  // Poisson solve Δ_s ψ = ω via weighted Jacobi
  function solvePoisson(iter=60){
    for(let it=0; it<iter; it++){
      for(let j=0;j<Nv;j++){
        const jp=(j+1)%Nv, jm=(j-1+Nv)%Nv;
        const su = sqrtg[j];
        const Auu = su*inv_uu[j];
        const Avv_p = sqrtg[jp]*inv_vv[jp];
        const Avv_m = sqrtg[jm]*inv_vv[jm];
        const coefCenter = (2*Auu/du/du + (Avv_p+Avv_m)/dv/dv);
        for(let i=0;i<Nu;i++){
          const ip=(i+1)%Nu, im=(i-1+Nu)%Nu;
          const c = idx(i,j);
          const cu= idx(ip,j), cm= idx(im,j);
          const cv= idx(i,jp), cvm=idx(i,jm);
          const rhs = su*omega[c];
          const sumN = Auu*(psi[cu]+psi[cm])/du/du + (Avv_p*psi[cv] + Avv_m*psi[cvm])/dv/dv;
          psiNew[c] = (sumN - rhs)/coefCenter;
        }
      }
      const tmp=psi; psi=psiNew; psiNew=tmp;
    }
  }

  // Velocity from streamfunction (intrinsic): contravariant components
  // u^u = (1/√g) ∂_v ψ,  u^v = -(1/√g) ∂_u ψ ; add harmonic v^u += g^{uu} H_u, v^v += g^{vv} H_v
  const vel_u = new Float64Array(Nu*Nv), vel_v = new Float64Array(Nu*Nv);
  function velocityFromPsi(){
    for(let j=0;j<Nv;j++){
      const jp=(j+1)%Nv, jm=(j-1+Nv)%Nv;
      const su = sqrtg[j];
      for(let i=0;i<Nu;i++){
        const ip=(i+1)%Nu, im=(i-1+Nu)%Nu;
        const c = idx(i,j);
        const u_u = (psi[idx(i,jp)] - psi[idx(i,jm)])/(2*dv)/su + inv_uu[j]*H_u;
        const u_v = -(psi[idx(ip,j)] - psi[idx(im,j)])/(2*du)/su + inv_vv[j]*H_v;
        vel_u[c] = u_u;
        vel_v[c] = u_v;
      }
    }
  }

  // Semi-Lagrangian advection on (u,v) torus
  function advectSL(src, dst, dt){
    for(let j=0;j<Nv;j++){
      for(let i=0;i<Nu;i++){
        const c = idx(i,j);
        let u = i*du, v = j*dv;
        const uu = vel_u[c], vv = vel_v[c];
        let ub = u - dt*uu, vb = v - dt*vv;
        ub = (ub%(2*Math.PI)+2*Math.PI)%(2*Math.PI);
        vb = (vb%(2*Math.PI)+2*Math.PI)%(2*Math.PI);
        const iu = Math.floor(ub/du), iv = Math.floor(vb/dv);
        const su = ub/du - iu, sv = vb/dv - iv;
        const c00=idx(iu,iv), c10=idx(iu+1,iv), c01=idx(iu,iv+1), c11=idx(iu+1,iv+1);
        dst[c] = (1-su)*(1-sv)*src[c00] + su*(1-sv)*src[c10] + (1-su)*sv*src[c01] + su*sv*src[c11];
      }
    }
  }

  // Diffusion
  const lapBuf = new Float64Array(Nu*Nv);
  function diffuseOmega(nu, dt){
    laplaceScalar(omega, lapBuf);
    for(let k=0;k<omega.length;k++) omega[k] += dt*nu*lapBuf[k];
  }

  // --------- Seeds ----------
  function seedTaylorGreen(U0=1.0, kx=4, ky=4){
    // build intrinsic streamfunction first, then omega = Δ_s ψ for consistency
    for(let j=0;j<Nv;j++){
      for(let i=0;i<Nu;i++){
        const u=i*du, v=j*dv;
        psi[idx(i,j)] = U0 * Math.sin(kx*u) * Math.cos(ky*v);
      }
    }
    laplaceScalar(psi, omega);
    for(let k=0;k<omega.length;k++) omega[k] += 0.05*(Math.random()-0.5); // small noise for filamentation
  }
  function seedBlob(){
    for(let j=0;j<Nv;j++){
      for(let i=0;i<Nu;i++){
        const u=i*du, v=j*dv;
        const du0 = Math.atan2(Math.sin(u-Math.PI), Math.cos(u-Math.PI));
        const dv0 = Math.atan2(Math.sin(v-Math.PI), Math.cos(v-Math.PI));
        const r2 = du0*du0 + dv0*dv0;
        omega[idx(i,j)] = 2.8*Math.exp(-r2/0.25);
      }
    }
  }
  function seedNoise(){
    for(let k=0;k<omega.length;k++) omega[k] = 0.3*(Math.random()-0.5);
  }

  // --------- Rendering: 3D torus ----------
  function torusXYZ(u,v){
    const x=(R0 + r0*Math.cos(v))*Math.cos(u);
    const y=(R0 + r0*Math.cos(v))*Math.sin(u);
    const z= r0*Math.sin(v);
    return {x,y,z};
  }
  const X=new Float64Array(Nu*Nv), Y=new Float64Array(Nu*Nv), Z=new Float64Array(Nu*Nv);
  function rebuildGeometry(){
    for(let j=0;j<Nv;j++){
      for(let i=0;i<Nu;i++){
        const p = torusXYZ(i*du, j*dv);
        const c = idx(i,j);
        X[c]=p.x; Y[c]=p.y; Z[c]=p.z;
      }
    }
  }
  rebuildGeometry();

  const I=[], J=[], K=[];
  function buildFaces(){
    I.length=0; J.length=0; K.length=0;
    for(let j=0;j<Nv;j++){
      const jp=(j+1)%Nv;
      for(let i=0;i<Nu;i++){
        const ip=(i+1)%Nu;
        const v00=idx(i,j), v10=idx(ip,j), v01=idx(i,jp), v11=idx(ip,jp);
        I.push(v00, v11); J.push(v10, v01); K.push(v11, v00);
      }
    }
  }
  buildFaces();

  // particle tracers
  const parts=[];
  function seedParticles(n=1500){
    parts.length=0;
    for(let k=0;k<n;k++) parts.push({u:Math.random()*2*Math.PI, v:Math.random()*2*Math.PI, age:Math.random()*100});
  }
  function particleStep(dt){
    for(const p of parts){
      const iu=Math.floor(p.u/du), iv=Math.floor(p.v/dv);
      const su=p.u/du-iu, sv=p.v/dv-iv;
      const c00=idx(iu,iv), c10=idx(iu+1,iv), c01=idx(iu,iv+1), c11=idx(iu+1,iv+1);
      const Uu0= (1-su)*(1-sv)*vel_u[c00] + su*(1-sv)*vel_u[c10] + (1-su)*sv*vel_u[c01] + su*sv*vel_u[c11];
      const Uv0= (1-su)*(1-sv)*vel_v[c00] + su*(1-sv)*vel_v[c10] + (1-su)*sv*vel_v[c01] + su*sv*vel_v[c11];
      p.u = (p.u + dt*Uu0 + 2*Math.PI)%(2*Math.PI);
      p.v = (p.v + dt*Uv0 + 2*Math.PI)%(2*Math.PI);
      p.age+=1;
    }
  }

  function omegaUnitArray(){
    const V=3.5; const arr=new Float64Array(omega.length);
    for(let k=0;k<omega.length;k++){
      const x=Math.max(-V, Math.min(V, omega[k]));
      arr[k]=(x+V)/(2*V);
    }
    return Array.from(arr);
  }

  function initPlot(){
    const intensity = omegaUnitArray();
    const meshTrace = { type:'mesh3d', x:Array.from(X), y:Array.from(Y), z:Array.from(Z), i:I, j:J, k:K, opacity:0.98, flatshading:true, intensity:intensity, colorscale:'Portland', cmin:0, cmax:1, showscale:false };
    const scatTrace = { type:'scatter3d', mode:'markers', x:[], y:[], z:[], marker:{size:2, color:'#ffffff', opacity:0.85} };
    Plotly.newPlot('torus3d',[meshTrace, scatTrace],{ height:600, paper_bgcolor:'#0b0f12', plot_bgcolor:'#0b0f12', scene:{xaxis:{visible:false}, yaxis:{visible:false}, zaxis:{visible:false}, camera:{eye:{x:1.5,y:1.4,z:1.1}}}, margin:{t:10,l:0,r:0,b:0} },{displaylogo:false});
  }
  let hairAdded=false;
  function redraw(){
    const intensity = omegaUnitArray();
    Plotly.restyle('torus3d', {'intensity':[intensity]}, [0]);
    const xs=[], ys=[], zs=[]; for(const p of parts){ const P=torusXYZ(p.u, p.v); xs.push(P.x); ys.push(P.y); zs.push(P.z); }
    Plotly.restyle('torus3d', {x:[xs], y:[ys], z:[zs]}, [1]);
    // hairline flow texture segments
    const hairN=700; const hx=[], hy=[], hz=[];
    for(let n=0;n<hairN;n++){
      const u=Math.random()*2*Math.PI, v=Math.random()*2*Math.PI;
      const iu=Math.floor(u/du), iv=Math.floor(v/dv);
      const su=u/du-iu, sv=v/dv-iv;
      const c00=idx(iu,iv), c10=idx(iu+1,iv), c01=idx(iu,iv+1), c11=idx(iu+1,iv+1);
      const Uu=(1-su)*(1-sv)*vel_u[c00] + su*(1-sv)*vel_u[c10] + (1-su)*sv*vel_u[c01] + su*sv*vel_u[c11];
      const Uv=(1-su)*(1-sv)*vel_v[c00] + su*(1-sv)*vel_v[c10] + (1-su)*sv*vel_v[c01] + su*sv*vel_v[c11];
      const eps=0.03;
      const p0=torusXYZ(u - eps*Uu, v - eps*Uv);
      const p1=torusXYZ(u + eps*Uu, v + eps*Uv);
      hx.push(p0.x,p1.x,null); hy.push(p0.y,p1.y,null); hz.push(p0.z,p1.z,null);
    }
    if(!hairAdded){
      Plotly.addTraces('torus3d', [{type:'scatter3d', mode:'lines', x:hx, y:hy, z:hz, line:{color:'rgba(255,255,255,0.18)', width:2}}]);
      hairAdded=true;
    } else {
      Plotly.restyle('torus3d', {x:[hx], y:[hy], z:[hz]}, [2]);
    }
  }

  // --------- Time stepping ----------
  let nuVal=0.0008; // baseline viscosity (slider overrides)
  let dtVal=parseFloat(document.getElementById('dt').value);
  let playing=false, raf=null, T=0;
  const statusEl = document.getElementById('status');

  function stepOnce(){
    solvePoisson(45);
    velocityFromPsi();
    advectSL(omega, omegaTmp, dtVal); const tmp=omega; omega=omegaTmp; omegaTmp=tmp;
    diffuseOmega(nuVal, dtVal);
    particleStep(dtVal);
    T += dtVal; redraw();
    statusEl.textContent = `t=${T.toFixed(2)} ν=${nuVal.toFixed(4)} | Hu=${H_u.toFixed(2)} Hv=${H_v.toFixed(2)}`;
  }
  function loop(){ if(!playing) return; const sub=3; for(let k=0;k<sub;k++) stepOnce(); raf=requestAnimationFrame(loop); }

  // UI
  document.getElementById('play').onclick = ()=>{ playing=!playing; document.getElementById('play').textContent=playing?'⏸ pause':'▶ play'; if(playing) loop(); else if(raf) cancelAnimationFrame(raf); };
  document.getElementById('step').onclick = ()=>{ if(!playing) stepOnce(); };
  document.getElementById('reset').onclick = ()=>{ playing=false; document.getElementById('play').textContent='▶ play'; resetAll(); };
  document.getElementById('nu').oninput  = (e)=>{ nuVal=parseFloat(e.target.value); };
  document.getElementById('dt').oninput  = (e)=>{ dtVal=parseFloat(e.target.value); };
  document.getElementById('hu').oninput  = (e)=>{ H_u=parseFloat(e.target.value); };
  document.getElementById('hv').oninput  = (e)=>{ H_v=parseFloat(e.target.value); };
  document.getElementById('seed').onchange = (e)=>{ reseed(e.target.value); };

  function reseed(kind){
    omega.fill(0); psi.fill(0);
    if(kind==='taylor') seedTaylorGreen(1.0,4,4);
    if(kind==='blob')   seedBlob();
    if(kind==='noise')  seedNoise();
    solvePoisson(60); velocityFromPsi();
    seedParticles(2200);
    redraw();
    stepOnce();
  }
  function resetAll(){
    dtVal=parseFloat(document.getElementById('dt').value);
    H_u=parseFloat(document.getElementById('hu').value);
    H_v=parseFloat(document.getElementById('hv').value);
    nuVal=parseFloat(document.getElementById('nu').value);
    T=0;
    reseed(document.getElementById('seed').value);
  }

  initPlot();
  resetAll();
  redraw();
})();
</script>
<section id="what-to-look-for-on-screen" class="level4" data-number="0.1.1">
<h4 data-number="0.1.1" class="anchored" data-anchor-id="what-to-look-for-on-screen"><span class="header-section-number">0.1.1</span> What to look for on screen</h4>
<ul>
<li>Free/normal behavior: choose “Taylor–Green” or “Blob” and press play; vorticity rolls into filaments and decays under the intrinsic Laplace–Beltrami while particles trace surface streamlines on the torus, showing standard Navier–Stokes evolution without flattening.</li>
<li>Harmonic memory/navigation: move the “harmonic u/v” sliders; these inject the two independent harmonic components (the Hodge harmonic 1‑forms) that persist around the torus cycles and bias transport, making topological “memory” obvious in particle motion and vorticity advection.</li>
</ul>
</section>
<section id="why-this-is-the-object-in-her-world" class="level4" data-number="0.1.2">
<h4 data-number="0.1.2" class="anchored" data-anchor-id="why-this-is-the-object-in-her-world"><span class="header-section-number">0.1.2</span> Why this is the object in her world</h4>
<ul>
<li>Operators are intrinsic (grad/div/curl/Laplace–Beltrami), not Euclidean ones pasted on a flat grid, so dynamics depend on the manifold metric and curvature as prescribed by the surface Navier–Stokes theory.</li>
<li>The harmonic degrees of freedom exist because the torus has nontrivial first cohomology; adding them yields circulation that neither decays under the Laplacian nor comes from a streamfunction, exactly the “memory” channel in the Helmholtz–Hodge decomposition on manifolds.</li>
</ul>
</section>
<section id="notes-and-extensions" class="level4" data-number="0.1.3">
<h4 data-number="0.1.3" class="anchored" data-anchor-id="notes-and-extensions"><span class="header-section-number">0.1.3</span> Notes and extensions</h4>
<ul>
<li>The Laplace–Beltrami discretization here is coordinate‑based; swapping it for a DEC Laplacian on a triangulated torus yields a mesh‑agnostic variant that preserves integral identities and circulation more tightly in complex geometries.</li>
<li>Semi‑Lagrangian advection is the same robust idea used in stable‑fluids; it is unconditionally stable for advection and suits interactive steps on manifold grids in the browser.</li>
</ul>
</section>
<section id="references" class="level4" data-number="0.1.4">
<h4 data-number="0.1.4" class="anchored" data-anchor-id="references"><span class="header-section-number">0.1.4</span> References</h4>
<ul>
<li>Reuther et al., “Solving the incompressible surface Navier–Stokes equation” (derivation and numerics of surface NS on general manifolds).</li>
<li>Nitschke et al., “Discrete Exterior Calculus for the Surface Navier–Stokes” (DEC operators, Hodge star and harmonic components on triangulated surfaces).</li>
<li>Stam, “Stable Fluids” (semi‑Lagrangian advection/projection idea that underpins robust real‑time solvers).</li>
</ul>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/mvtta\.github\.io\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p><a href="mailto:mvtta@proton.me">contact</a></p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p>Valdetaro M, 2025</p>
</div>
  </div>
</footer>




<script src="../../../site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>